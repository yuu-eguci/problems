"""
dp の練習

問題
- a = n 個の int が入ってるリスト
- a から好きなだけ int を選んで足したときの最大値を出せ
- ぶっちゃけリストから正の数だけ出して足せばいいんだけど、 dp の練習だから↓の方法で解こう

方法
- dp(i) っていうものを前提にする
    - dp(0) a から何も選んでいないときの最大値。もちろん 0 だよ
    - dp(1) a[0] までの int を選べるときの最大値。そりゃもちろん max([0, a[0]]) だよ
    - dp(2) a[1] までの……以下同じ。もちろん max([dp(1), a[1]]) だよ
    - と、いうことにする
- そうなると……
    - dp(i) a[i-1] までの……以下同じ。もちろん max([dp(i-1), dp(i-1) + a[i-1]]) だよ
    - dp(i+1) a[i] までの……以下同じ。もちろん max([dp(i), dp(i) + a[i]]) だよ
    - ということになる。これ漸化式っていうらしいよ知らんけど
- これをプログラムにしてみましょう
"""


def practice(lis: list) -> int:

    # 表を作ります。
    # 動的計画法を使うときの表は dp って名前にすることが多いみたいです。
    # いちばん左は「リストから 0 個選べるとき」の最大値です。もちろん 0。
    dp = [0]

    # 「リストから[リストの個数]選べるとき」の計算をするので、リストの個数ぶん回します。
    for i in range(len(lis)):

        # 「ひとつ前の値」と「今のところの最大値に lis[i] を足したもの」を比べます。
        # NOTE: dp[i] は「0 個選べるとき」のマスで、 lis[i] は「1 個目の要素」なのがちょっとわかりづらいトコ。
        dp.append(max(dp[i], dp[i] + lis[i]))

    print(dp)

    # for が終わると dp の最後の値が、全部の値を比べた結果の最大値になってるはずだ。
    return dp[-1]


print(practice([7, -6, 9]) == 16)
print(practice([-9, -16]) == 0)
